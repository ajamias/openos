

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>44. Input and Output &#8212; Introduction to Operating Systems</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'devices/devices';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="45. More on Disks" href="disk2.html" />
    <link rel="prev" title="43. Review" href="../sync/review.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro/pref.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro/pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro/intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/purpose.html">2. Purpose of operating systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/structure.html">3. Operating System Structure &amp; Unix/Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/abstractions.html">4. Operating System Abstractions</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../intro/tools.html">5. What you should know</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-shell.html">5.1. Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-editors.html">5.2. Editors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-make.html">5.3. Makefiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-git.html">5.4. Git Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-gdb.html">5.5. GDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-c.html">5.6. The C Programming Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-testing.html">5.7. Unit Tests</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Virtual Processor</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../scheduling/intro.html">6. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/process.html">7. Virtualizing a CPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/scheduling.html">8. Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/real_sched.html">9. A Look at the Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/review.html">10. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">File Systems</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../fs/intro.html">11. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/interface.html">12. File System Abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/diskhw.html">13. A bit about Disks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/disklayout.html">14. File System Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_track_used.html">15. Disk Layout:Tracking Used Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_track_free.html">16. Disk Layout:Tracking Free Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_name.html">17. Disk Layout:Implementing Name Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_failures.html">18. Disk Layout:Dealing with Failures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_ex_exx.html">19. Disk Layout:Examples of Real World File Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/kernelimp.html">20. Kernel implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/review.html">21. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Virtual Memory</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../mm/intro.html">22. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/phys-and-seg.html">23. Memory management before paged virtual memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/virt-paging.html">24. Paging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/page-tables.html">25. Page Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/reclamation.html">26. Memory reclaiming algorithms.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/page-size.html">27. Page Sizes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/misc.html">28. Other topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/buffer-cache.html">29. Buffer Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/pagefaults.html">30. Memory Management Dynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/realworld.html">31. Memory management in the real world</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/concl.html">32. Conclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mm/review.html">33. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concurrency</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../sync/sync.html">34. Introduction to Concurrency, Synchronization and Deadlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/sharing.html">35. Cooperating Processes and Inter-process Communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/criticalsection.html">36. The Critical Section Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/locks.html">37. Implementing Locks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/ordering.html">38. Ordering Thread Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/concurrency_bugs.html">39. Common Concurrency Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/readmostly.html">40. Read-Dominated Workloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/hardware_challenges.html">41. Challenges of Modern Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/linux_locking.html">42. Locking in the Linux Kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/review.html">43. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Other Topics</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">44. Input and Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="disk2.html">45. More on Disks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/virt.html">46. Virtualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sec/sec.html">47. Security</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../misc/howto.html">48. How to read this book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/Contributing.html">49. Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/bib.html">50. Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://jupyterhub-opf-jupyterhub.apps.smaug.na.operate-first.cloud/hub/user-redirect/git-pull?repo=https%3A//github.com/OpenOSOrg/openos&urlpath=lab/tree/openos/content/devices/devices.ipynb&branch=main" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onJupyterHub"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="btn__text-container">JupyterHub</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/OpenOSOrg/openos" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/OpenOSOrg/openos/edit/main/content/devices/devices.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/OpenOSOrg/openos/issues/new?title=Issue%20on%20page%20%2Fdevices/devices.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/devices/devices.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Input and Output</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#io-hardware">44.1. IO Hardware</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#structure-of-a-computer">44.1.1. Structure of a computer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#controllers">44.1.2. Controllers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-the-controller">44.1.3. Accessing the controller</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polled-vs-interrupt-driven-i-o">44.1.4. Polled vs. Interrupt-driven I/O</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interrupts">44.1.5. Interrupts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-memory-access-dma">44.1.6. Direct Memory Access (DMA)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#i-o-software-and-device-drivers">44.2. I/O Software and Device Drivers</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fundamental-goals">44.2.1. Fundamental Goals</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-it-all-together">44.3. Putting it all together</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="input-and-output">
<span id="cont-other-devices"></span><h1><span class="section-number">44. </span>Input and Output<a class="headerlink" href="#input-and-output" title="Permalink to this headline">#</a></h1>
<p>Input/Output (I/O) devices are crucial to the operation of a computer.
The data that a program processes — as well as the program binary
itself — must be loaded into memory from some I/O device such as a
disks, networks, or keyboard. Similarly, without a way to output the
results of a computation to the monitors or to storage, those results would
be lost.</p>
<p>One of the primary functions of the operating system is to
manage these I/O devices. It should control access to them, as well as
providing a consistent programming interface across a wide range of
hardware devices with similar functionality but differing details.</p>
<figure class="align-right" id="devs-fig-rep">
<a class="reference internal image-reference" href="../_images/purpose-OS-source-12.drawio.png"><img alt="../_images/purpose-OS-source-12.drawio.png" src="../_images/purpose-OS-source-12.drawio.png" style="width: 300pt;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.1 </span><span class="caption-text">Supporting devices</span><a class="headerlink" href="#devs-fig-rep" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We first describe the characteristics of device hardware, and then how the OS interacts with that hardware.</p>
<section id="io-hardware">
<h2><span class="section-number">44.1. </span>IO Hardware<a class="headerlink" href="#io-hardware" title="Permalink to this headline">#</a></h2>
<p>We outline structure of a standard computer, device controllers, how the OS interacts with the controller using port and memory mapped I/O, how interrupts work, and conclude with a discussion of Direct Memory Access (DMA).</p>
<figure class="align-right" id="simplecomputer-fig2">
<a class="reference internal image-reference" href="../_images/hardware.png"><img alt="../_images/hardware.png" src="../_images/hardware.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.2 </span><span class="caption-text">An abstract model of a computer.</span><a class="headerlink" href="#simplecomputer-fig2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="structure-of-a-computer">
<h3><span class="section-number">44.1.1. </span>Structure of a computer<a class="headerlink" href="#structure-of-a-computer" title="Permalink to this headline">#</a></h3>
<p>At the start of the course, we <a class="reference internal" href="../intro/purpose.html#cont-gs-purpose-hw"><span class="std std-ref">presented</span></a> a simple model of hardware (<a class="reference internal" href="#simplecomputer-fig2"><span class="std std-numref">Fig. 44.2</span></a>) was discussed. The CPU is connected to high speed memory, and through a lower speed bus to a network controller and disk controller that are in turn connected to a network (ethernet in this case) and a disk.</p>
<p><a class="reference internal" href="#fig-iobus-1"><span class="std std-numref">Fig. 44.3</span></a> shows the more complicated architecture of a relatively modern
Intel-architecture. Different parts of the
system are connected by buses, or communication channels, operating at
various speeds. The Front-Side Bus carries all memory transactions which
miss in L1 and L2 cache, and the North Bridge directs these transactions
to memory (DDR2 bus) or I/O devices (PCIe bus) based on their address.
The PCI Express (PCIe) is somewhat slower than the front-side bus, but
can be extended farther; it connects all the I/O devices on the system.
In some cases (like USB and SATA), a controller connected to the PCIe
bus (although typically located on the motherboard itself) may interface
to a yet slower external interface. Finally, the ISA bus, used to connect slow devices like keyboards, is a vestige of
the original IBM PC; for some reason, they’ve never moved some crucial
system functions off of it, so it’s still needed.<a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
<figure class="align-default" id="fig-iobus-1">
<a class="reference internal image-reference" href="../_images/iobus-fig1.png"><img alt="../_images/iobus-fig1.png" src="../_images/iobus-fig1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.3 </span><span class="caption-text">A standard Intel PC Architecture</span><a class="headerlink" href="#fig-iobus-1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<aside class="sidebar">
<p>The term “bus” was taken from electrical engineering; in high-power
electric systems a <em>bus bar</em> is a copper bar used to distribute power to
multiple pieces of equipment. A simple bus like this one distributes
address and data signals in much the same way.</p>
</aside>
</section>
<section id="controllers">
<h3><span class="section-number">44.1.2. </span>Controllers<a class="headerlink" href="#controllers" title="Permalink to this headline">#</a></h3>
<p>I/O devices typically connected as PCI/ISA cards installed on the mother board have, in additional to their mechanical components, controllers that manage the device. The task of this controller is to convert from the operations on the bus to device specific operations.  The processor interacts with these controllers by reading and writing controller registers.</p>
<figure class="align-default" id="fig-intelnic">
<a class="reference internal image-reference" href="../_images/modernnic-regs.png"><img alt="../_images/modernnic-regs.png" src="../_images/modernnic-regs.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.4 </span><span class="caption-text">Registers of an Intel network interface card.  It contains around 5600 32-bit registers broken down as shown. Note that complex OSes, like Linux, only initialize around 1000 of these registers.</span><a class="headerlink" href="#fig-intelnic" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To understand how complex modern devices can be, consider <a class="reference internal" href="#fig-intelnic"><span class="std std-numref">Fig. 44.4</span></a> that shows the breakdown of registers of a modern Intel NIC.  There are over 5600 32 bit registers, providing enormous complexity in how the OS can configure and interact with the device.  As a result, these controllers often have a general purpose CPU, a fair amount of RAM to buffer data going to/from the device, and often some permanent flash storage.  The software that used on these processors, typically referred to as firmware is complex enough that it must be regularly upgraded to deal with bugs.  This turns out to be a massive attack surface in today’s computers. For example the following <a class="reference external" href="https://www.vice.com/en/article/ypwkwk/the-nsas-undetectable-hard-drive-hack-was-first-demonstrated-a-year-ago">story</a> describes one technique that has been used by the NSA to embed undetectable spyware on disks.</p>
</section>
<section id="accessing-the-controller">
<h3><span class="section-number">44.1.3. </span>Accessing the controller<a class="headerlink" href="#accessing-the-controller" title="Permalink to this headline">#</a></h3>
<p>The OS talks with the controller by reading and writing registers of the device and by reading and writing data that is buffered by the controller.  Certain CPUs, including Intel
architecture, contain support for a secondary I/O bus, with a smaller
address width and accessed via special instructions. (e.g. “IN 0x100” to
read a byte from I/O location 0x100, which has nothing to do with
reading a byte from memory location 0x100). This is typically called port mapped I/O.</p>
<p>All architectures support <em>Memory-mapped I/O</em>, where devices can be
mapped in the physical memory space and accessed via standard load and
store instructions.</p>
<p>Depending on the system architecture, the device
may be responsible for decoding the full address and determining when it
has been selected, or a select signal may indicate when a particular
slot on the bus is being accessed. Almost all computers today use a
version of the PCI bus, which uses memory-mapped access, and at boot
time, assigns each I/O device a physical address range to which it
should respond.</p>
</section>
<section id="polled-vs-interrupt-driven-i-o">
<h3><span class="section-number">44.1.4. </span>Polled vs. Interrupt-driven I/O<a class="headerlink" href="#polled-vs-interrupt-driven-i-o" title="Permalink to this headline">#</a></h3>
<figure class="align-right" id="fig-iobus-polled">
<a class="reference internal image-reference" href="../_images/iobus-polled.png"><img alt="../_images/iobus-polled.png" src="../_images/iobus-polled.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.5 </span><span class="caption-text">Polled I/O</span><a class="headerlink" href="#fig-iobus-polled" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The
simplest way to control an I/O device is for the CPU to issue commands
and then wait, polling a device status register until the operation is
complete. In <a class="reference internal" href="#fig-iobus-polled"><span class="std std-numref">Fig. 44.5</span></a> (a) an application requests I/O via e.g. a
<code class="docutils literal notranslate"><span class="pre">read</span></code> system call; the OS (step 1) then writes to the device command
register to start an operation, after which (step 2) it begins to poll
the status register to detect completion. Meanwhile (step 3) the device
carries out the operation, after which (step 4) polling by the OS
detects that it is complete, and finally (step 5) the original request
(e.g. <code class="docutils literal notranslate"><span class="pre">read</span></code>) can return to the application.</p>
<figure class="align-right" id="fig-iobus-inter">
<a class="reference internal image-reference" href="../_images/iobus-irq.png"><img alt="../_images/iobus-irq.png" src="../_images/iobus-irq.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.6 </span><span class="caption-text">Interrupt<br />
driven I/O</span><a class="headerlink" href="#fig-iobus-inter" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The alternate is interrupt-driven I/O, as
shown in
<a class="reference internal" href="#fig-iobus-inter"><span class="std std-numref">Fig. 44.6</span></a> (b). After (step 1) issuing a request to
the hardware, the OS (step 2) puts the calling process to sleep and
switches to another process while (step 3) the hardware handles the
request. When the I/O is complete, the device (step 4) raises an
interrupt. The interrupt handler then finishes the request. In the
illustrated example, the interrupt handler (step 5) reads data that has
become available, and then (step 6) wakes the waiting process, which
returns from the I/O call (step 7) and continues.</p>
</section>
<section id="interrupts">
<h3><span class="section-number">44.1.5. </span>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">#</a></h3>
<p>We have already mentioned Interrupts many times, but nows a good time to flesh them out in a bit more detail.
To handle asynchronous I/O events, CPUs provide an <em>interrupt</em>
mechanism. In response to a signal from an I/O device the CPU executes
an <em>interrupt handler</em> function, returning to its current execution when
the handler is done. The CPU essentially performs a forced function
call, saving the address of the next instruction on the stack and
jumping to the interrupt handler; the difference is that instead of
doing this in response to a CALL instruction, it does it at some
arbitrary time (but <em>between</em> two instructions) when the interrupt
signal is asserted.</p>
<p>Most CPUs have several interrupt inputs; these correspond to an
<em>interrupt vector table</em> in memory, either at a fixed location or
identified by a special register, giving the addresses of the
corresponding interrupt handlers. As an example, below we see the corresponding table for an 8088
CPU as found in the original IBM PC, which provides handler addresses
for external hardware interrupts as well as <em>exceptions</em> which halt
normal program execution, such as dividing by zero or attempting to
execute an illegal instruction.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Index</span>          <span class="n">Description</span>          <span class="n">DOS</span> <span class="n">name</span>
  <span class="o">-------</span> <span class="o">-------------------------</span> <span class="o">------------</span>
  <span class="mi">0</span>            <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>       
  <span class="mi">1</span>              <span class="n">single</span> <span class="n">step</span>        
  <span class="mi">2</span>             <span class="n">non</span><span class="o">-</span><span class="n">maskable</span>        
  <span class="mi">3</span>              <span class="n">debug</span> <span class="k">break</span>        
  <span class="mi">4</span>        <span class="n">debug</span> <span class="k">break</span> <span class="n">on</span> <span class="n">overflow</span>  
  <span class="mi">5</span>               <span class="o">-</span><span class="n">unused</span><span class="o">-</span>          
  <span class="mi">6</span>            <span class="n">invalid</span> <span class="n">instr</span><span class="o">.</span>       
  <span class="mi">7</span>               <span class="o">-</span><span class="n">unused</span><span class="o">-</span>          
  <span class="mi">8</span>             <span class="n">system</span> <span class="n">timer</span>            <span class="n">IRQ0</span>
  <span class="mi">9</span>            <span class="n">keyboard</span> <span class="nb">input</span>           <span class="n">IRQ1</span>
  <span class="mi">10</span>           <span class="n">line</span> <span class="n">printer</span> <span class="mi">2</span>        <span class="n">IRQ2</span><span class="p">,</span> <span class="n">LPT2</span>
  <span class="mi">11</span>            <span class="n">serial</span> <span class="n">port</span> <span class="mi">2</span>        <span class="n">IRQ3</span><span class="p">,</span> <span class="n">COM2</span>
  <span class="mi">12</span>            <span class="n">serial</span> <span class="n">port</span> <span class="mi">1</span>        <span class="n">IRQ4</span><span class="p">,</span> <span class="n">COM1</span>
  <span class="mi">13</span>              <span class="n">hard</span> <span class="n">disk</span>             <span class="n">IRQ5</span>
  <span class="mi">14</span>             <span class="n">floppy</span> <span class="n">disk</span>            <span class="n">IRQ6</span>
  <span class="mi">15</span>           <span class="n">line</span> <span class="n">printer</span> <span class="mi">1</span>        <span class="n">IRQ7</span><span class="p">,</span> <span class="n">LPT1</span>
  <span class="mi">16</span><span class="o">-</span>         <span class="n">software</span><span class="o">-</span><span class="n">defined</span>      
  <span class="mi">255</span>            <span class="n">interrupts</span>         

  <span class="p">:</span> <span class="mi">8086</span><span class="o">/</span><span class="mi">8088</span> <span class="n">interrupts</span> <span class="k">as</span> <span class="n">defined</span> <span class="n">by</span> <span class="n">the</span> <span class="n">IBM</span> <span class="n">PC</span> <span class="n">hardware</span><span class="o">.</span>
</pre></div>
</div>
<p>The simplest interrupt-generating device is a <em>timer</em>, which does
nothing except generate an interrupt at a periodic interval. As shown below, we see why it is called a timer—one of its
most common uses is to keep track of time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">time_in_ticks</span><span class="p">;</span> 
    <span class="n">timer_interrupt_handler</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">time_in_ticks</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Another simple use for interrupts is for notification of keyboard input.
Besides being useful for a “cancel” command like control-C, this is also
very useful for <em>type-ahead</em>. On slower computers (e.g. the original IBM
PC executed less than half a million instructions per second) a fast
typist can hit multiple keys while a program is busy. A simple keyboard
interface only holds one keystroke, causing additional ones to be lost.
By using the keyboard interrupt, the operating system can read these
keystrokes and save them, making them available to the program the next
time it checks for input.</p>
</section>
<section id="direct-memory-access-dma">
<h3><span class="section-number">44.1.6. </span>Direct Memory Access (DMA)<a class="headerlink" href="#direct-memory-access-dma" title="Permalink to this headline">#</a></h3>
<p>The CPU could copying data
between I/O devices and memory using normal memory load and store
instructions. Such an approach works well on computers such as the Apple
II or the original IBM PC which run at a few MHz, where the address and
data buses can be extended at full speed to external I/O cards. A modern
CPU runs at over 3 GHz, however; during a single clock cycle light can
only travel about 4 inches, and electrical signals even less. <a class="reference internal" href="#fig-iobus-latency"><span class="std std-numref">Fig. 44.7</span></a>
shows example latencies for a modern CPU
(in this case an Intel i5, with L3 cache omitted) to read a data value
from L1 and L2 cache, a random location in memory (sequential access is
faster), and a register on a device on the PCIe bus. (e.g. the disk or
ethernet controller) In such a system, reading data from a device in
4-byte words would result in a throughput of 5 words every microsecond,
or 20MB/s — far slower than a modern network adapter or disk
controller.</p>
<figure class="align-default" id="fig-iobus-latency">
<a class="reference internal image-reference" href="../_images/iobus-latency.png"><img alt="../_images/iobus-latency.png" src="../_images/iobus-latency.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.7 </span><span class="caption-text">Latency between CPU and various levels of memory/IO hierarchy</span><a class="headerlink" href="#fig-iobus-latency" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-iobus-dma">
<a class="reference internal image-reference" href="../_images/iobus-dma.png"><img alt="../_images/iobus-dma.png" src="../_images/iobus-dma.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.8 </span><span class="caption-text">DMA access for high-speed data transfer</span><a class="headerlink" href="#fig-iobus-dma" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<aside class="sidebar">
<p>As CPU speeds have become faster and faster, RAM and I/O devices have
only slowly increased in speed. The strategies for coping with the high
relative latency of RAM and I/O are very different, however—caching
works quite well with RAM, which stores data generated by the CPU, while
I/O (at least the input side) involves reading new data; here latency is
overcome by pipelining, instead.</p>
</aside>
<p>Almost all computers today use the PCIe bus. Transactions on the PCIe
bus require a negotiation stage, when the CPU (or a device) requests
access to bus resources, and then is able to perform a transaction after
being granted access. In addition to basic read and write requests, the
bus also supports Direct Memory Access (DMA), where I/O devices are able
to read or write memory directly without CPU intervention.
<a class="reference internal" href="#fig-iobus-dma"><span class="std std-numref">Fig. 44.8</span></a> shows a single programmed-I/O read (top)
compared to a DMA burst transfer (bottom). While the read request
requires a round trip to read each and every 4-byte word, once the DMA
transfer is started it is able to transfer data at a rate limited by the
maximum bus speed. (For an 8 or 16-lane PCIe card this limit is many
GB/s)</p>
<p>A device typically requires multiple parameters to perform an operation
and transfer the data to or from memory. In the case of a disk
controller, for instance, these parameters would include the type of
access (read or write), the disk locations to be accessed, and the
memory address where data will be stored or retrieved from. Rather than
writing each of these parameters individually to device registers, the
parameters are typically combined in memory in what is called a <em>DMA
descriptor</em>, such as the one shown in  <a class="reference internal" href="#fig-iobus-desc"><span class="std std-numref">Fig. 44.9</span></a>. A single write is then used to tell the
device the address of this descriptor, and the device can read the
entire descriptor in a single DMA read burst. In addition to being more
efficient than multiple programmed I/O writes, this approach also allows
multiple requests to be queued for a device. (In the case of queued disk
commands, the device may even process multiple such requests
simultaneously.) When an I/O completes, the device notifies the CPU via
an interrupt, and writes status information (such as success/failure)
into a field in the DMA descriptor. (or sometimes in a device register, for
simple devices which do not allow multiple outstanding requests.) The
interrupt handler can then determine which operations have completed,
free their DMA descriptors, and notify any waiting processes.</p>
<aside class="sidebar">
<p><strong>Cache-coherent I/O:</strong> The PCIe bus is <em>cache-consistent</em>; many earlier
I/O buses weren’t. Consider what would happen if the CPU wrote a value
to location 1000 (say that’s the command/status field of a DMA
descriptor), then the device wrote a new value to that same location,
and finally the CPU tried to read it back?</p>
</aside>
<figure class="align-default" id="fig-iobus-desc">
<a class="reference internal image-reference" href="../_images/iobus-desc.png"><img alt="../_images/iobus-desc.png" src="../_images/iobus-desc.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.9 </span><span class="caption-text">List of typical DMA descriptors</span><a class="headerlink" href="#fig-iobus-desc" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="i-o-software-and-device-drivers">
<h2><span class="section-number">44.2. </span>I/O Software and Device Drivers<a class="headerlink" href="#i-o-software-and-device-drivers" title="Permalink to this headline">#</a></h2>
<section id="fundamental-goals">
<h3><span class="section-number">44.2.1. </span>Fundamental Goals<a class="headerlink" href="#fundamental-goals" title="Permalink to this headline">#</a></h3>
<p>The operating system software that interacts with devices must:</p>
<ul class="simple">
<li><p><strong>Provide Device Independence:</strong> Programs should be able to access any similar device without worrying about the specific device available.  For example, you should be able to read data from a floppy, hard drive, or CD-ROM without caring which device is available.  As another example, your <em>vim</em> editor should be able to work if you are connecting a dumb terminal to your computer, or if you are using an emulated terminal provided by our course staff.</p></li>
<li><p><strong>Handle Errors:</strong> Many errors are transient, and we want to handle them as close to the hardware as possible.  For example, if a network is unavailable for a brief period of time, we don’t want to close all the connections.  If we get an error reading a disk block, the OS might try re-reading assuming that there was a transient failure, or correct the error using some form of error correcting code.</p></li>
<li><p><strong>Support synchronous interfaces:</strong> In reality, all devices interact with the OS asynchronously, where some character appears from a terminal when a user hits a key, or a network packet arrives when clients make new requests to a server.  On the other hand, generally the programming interfaces users have are synchronous, for example, using a <code class="docutils literal notranslate"><span class="pre">read</span></code> to a network socket or file system.  The OS keeps translates between the blocking calls by applications and the innate events that come in from devices.</p></li>
<li><p><strong>Buffering:</strong> Related to asynchronous interactions, the operating system normally manages buffers to enable data to be transferred to and from the devices to match the performance needs of the device.  We have already seen how memory management creates a massive buffer cache to buffer millions of blocks in memory.  On the other hand, if a program is dumping huge files to a slow character device, the OS needs to buffer the data, and feed it to the device at the rate that the device can handle.</p></li>
</ul>
<figure class="align-default" id="fig-dev-layers">
<a class="reference internal image-reference" href="../_images/dev-layers.png"><img alt="../_images/dev-layers.png" src="../_images/dev-layers.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.10 </span><span class="caption-text">OS layers</span><a class="headerlink" href="#fig-dev-layers" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To perform this functionality, much like when we discussed the VFS layer in file systems, as shown in <a class="reference internal" href="#fig-dev-layers"><span class="std std-numref">Fig. 44.10</span></a> there is generic I/O code that provides services like buffering, generalized error reporting, and enables a set of standardized device interfaces. The three kind of standard device types are:</p>
<ol class="arabic simple">
<li><p>Block devices: e.g. SSDs, Hard drives, CDROMs</p></li>
<li><p>Character devices: ttys, pipes, …</p></li>
<li><p>Network devices: ethernet, token ring,…</p></li>
</ol>
<p>There are many many devices drivers of each type. In fact, over 60% of Linux source code today with device drivers involving 10s of millions of LOC. Much of this code is provided by device manufacturers, and is the most buggy part of the OS.</p>
<p>Drivers responsibilities include:</p>
<ul class="simple">
<li><p>Device initialization</p></li>
<li><p>Accept read-write request from the OS: i.e., take commands from higher levels in the OS and translate them into hardware requests</p></li>
<li><p>Start the device if necessary (e.g., start spinning the CD-ROM)</p></li>
<li><p>Check if device is available: if not, wait</p></li>
<li><p>Wait for results; typically blocking client request until interrupt occurs</p></li>
<li><p>Check for possible errors</p></li>
<li><p>Return results, and finally</p></li>
<li><p>Power management – put the device to sleep when it’s not being used</p></li>
</ul>
</section>
</section>
<section id="putting-it-all-together">
<h2><span class="section-number">44.3. </span>Putting it all together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">#</a></h2>
<p><a class="reference internal" href="#fig-iobus-driver"><span class="std std-numref">Fig. 44.11</span></a> illustrates the I/O process for a typical
device from user-space application request through the driver, hardware
I/O operation, interrupt, and finally back to user space.</p>
<figure class="align-default" id="fig-iobus-driver">
<a class="reference internal image-reference" href="../_images/iobus-driver.png"><img alt="../_images/iobus-driver.png" src="../_images/iobus-driver.png" style="width: 70%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 44.11 </span><span class="caption-text">Putting it together</span><a class="headerlink" href="#fig-iobus-driver" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In more detail:</p>
<ul class="simple">
<li><p>The user process executes a <code class="docutils literal notranslate"><span class="pre">read</span></code> system call, which in turn invokes
the driver <code class="docutils literal notranslate"><span class="pre">read</span></code> operation, found via the <code class="docutils literal notranslate"><span class="pre">read</span></code> method of the file
operations structure.</p></li>
<li><p>The driver fills in a DMA descriptor (in motherboard RAM), writes the
physical address of the descriptor to a device register (generating a
Memory Write operation across the PCIe bus), and then goes to sleep.</p></li>
<li><p>The device issues a PCIe Memory Read Multiple command to read the DMA
descriptor from RAM.</p></li>
<li><p>The device does some sort of I/O. (e.g. read from a disk, or receive a
network packet)</p></li>
<li><p>A Memory Write and Invalidate operation is used to write the received
data back across the PCIe bus to the motherboard RAM, and to tell the
CPU to invalidate any cached copies of those addresses.</p></li>
<li><p>A hardware interrupt from the device causes the device driver interrupt
handler to run.</p></li>
<li><p>The interrupt handler wakes up the original process, which is currently
in kernel space in the device driver read method, in a call to something
like <code class="docutils literal notranslate"><span class="pre">interruptible_sleep_on</span></code>. After waking up, the read method copies
the data to the user buffer and returns.</p></li>
</ul>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>The primary difference between this figure and contemporary
systems is that (a) the memory bus is DDR3 or DDR4, and (b) the
north bridge is located on the CPU chip, with no external front-side
bus.</p>
</dd>
</dl>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./devices"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../sync/review.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">43. </span>Review</p>
      </div>
    </a>
    <a class="right-next"
       href="disk2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">45. </span>More on Disks</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#io-hardware">44.1. IO Hardware</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#structure-of-a-computer">44.1.1. Structure of a computer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#controllers">44.1.2. Controllers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-the-controller">44.1.3. Accessing the controller</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polled-vs-interrupt-driven-i-o">44.1.4. Polled vs. Interrupt-driven I/O</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interrupts">44.1.5. Interrupts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-memory-access-dma">44.1.6. Direct Memory Access (DMA)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#i-o-software-and-device-drivers">44.2. I/O Software and Device Drivers</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fundamental-goals">44.2.1. Fundamental Goals</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-it-all-together">44.3. Putting it all together</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By (see contributing chapter book)
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>