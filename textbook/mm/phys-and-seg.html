

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>23. Memory management before paged virtual memory &#8212; Introduction to Operating Systems</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'mm/phys-and-seg';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="24. Paging" href="virt-paging.html" />
    <link rel="prev" title="22. Introduction" href="intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro/pref.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro/pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro/intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/purpose.html">2. Purpose of operating systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/structure.html">3. Operating System Structure &amp; Unix/Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/abstractions.html">4. Operating System Abstractions</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../intro/tools.html">5. What you should know</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-shell.html">5.1. Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-editors.html">5.2. Editors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-make.html">5.3. Makefiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-git.html">5.4. Git Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-gdb.html">5.5. GDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-c.html">5.6. The C Programming Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/tools-testing.html">5.7. Unit Tests</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Virtual Processor</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../scheduling/intro.html">6. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/process.html">7. Virtualizing a CPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/scheduling.html">8. Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/real_sched.html">9. A Look at the Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduling/review.html">10. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">File Systems</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../fs/intro.html">11. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/interface.html">12. File System Abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/diskhw.html">13. A bit about Disks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/disklayout.html">14. File System Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_track_used.html">15. Disk Layout:Tracking Used Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_track_free.html">16. Disk Layout:Tracking Free Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_name.html">17. Disk Layout:Implementing Name Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_failures.html">18. Disk Layout:Dealing with Failures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/dl_ex_exx.html">19. Disk Layout:Examples of Real World File Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/kernelimp.html">20. Kernel implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/review.html">21. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Virtual Memory</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="intro.html">22. Introduction</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">23. Memory management before paged virtual memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="virt-paging.html">24. Paging</a></li>
<li class="toctree-l1"><a class="reference internal" href="page-tables.html">25. Page Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="reclamation.html">26. Memory reclaiming algorithms.</a></li>
<li class="toctree-l1"><a class="reference internal" href="page-size.html">27. Page Sizes</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">28. Other topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="buffer-cache.html">29. Buffer Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="pagefaults.html">30. Memory Management Dynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="realworld.html">31. Memory management in the real world</a></li>
<li class="toctree-l1"><a class="reference internal" href="concl.html">32. Conclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="review.html">33. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concurrency</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../sync/sync.html">34. Introduction to Concurrency, Synchronization and Deadlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/sharing.html">35. Cooperating Processes and Inter-process Communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/criticalsection.html">36. The Critical Section Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/locks.html">37. Implementing Locks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/ordering.html">38. Ordering Thread Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/concurrency_bugs.html">39. Common Concurrency Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/readmostly.html">40. Read-Dominated Workloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/hardware_challenges.html">41. Challenges of Modern Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/linux_locking.html">42. Locking in the Linux Kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sync/review.html">43. Review</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Other Topics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../devices/devices.html">44. Input and Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devices/disk2.html">45. More on Disks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/virt.html">46. Virtualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sec/sec.html">47. Security</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../misc/howto.html">48. How to read this book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/Contributing.html">49. Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/bib.html">50. Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://jupyterhub-opf-jupyterhub.apps.smaug.na.operate-first.cloud/hub/user-redirect/git-pull?repo=https%3A//github.com/OpenOSOrg/openos&urlpath=lab/tree/openos/content/mm/phys-and-seg.ipynb&branch=main" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onJupyterHub"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="btn__text-container">JupyterHub</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/OpenOSOrg/openos" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/OpenOSOrg/openos/edit/main/content/mm/phys-and-seg.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/OpenOSOrg/openos/issues/new?title=Issue%20on%20page%20%2Fmm/phys-and-seg.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/mm/phys-and-seg.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Memory management before paged virtual memory</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#simple-physical-memory-management">23.1. Simple physical memory management.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-virtual-memory">23.2. Segmentation - Virtual Memory</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-base-and-bounds-translation">23.2.1. Segmentation - Base and Bounds translation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-aka-base-and-bounds-translation">23.3. Segmentation(AKA base and bounds translation).</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#single-segments-per-address-space">23.3.1. Single segments per address space</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-segments-per-address-space">23.3.2. Multiple segments per address space.</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#private-versus-global-segments">23.3.3. Private versus Global segments.</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fragmentation-and-compaction">23.3.3.1. Fragmentation and Compaction.</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#swapping">23.3.3.2. Swapping.</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#limitations-of-segmentation">23.3.3.3. Limitations of segmentation.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="memory-management-before-paged-virtual-memory">
<span id="cont-mm-beforepaging"></span><h1><span class="section-number">23. </span>Memory management before paged virtual memory<a class="headerlink" href="#memory-management-before-paged-virtual-memory" title="Permalink to this headline">#</a></h1>
<section id="simple-physical-memory-management">
<span id="cont-mm-overview-simple"></span><h2><span class="section-number">23.1. </span>Simple physical memory management.<a class="headerlink" href="#simple-physical-memory-management" title="Permalink to this headline">#</a></h2>
<p>From a hardware perspective, the simplest memory management model is to have processes just use the physical address space; where instructions executed on the processor directly reference physical memory addresses.  For example, if the application wants to load a register, from location <code class="docutils literal notranslate"><span class="pre">0x1234</span></code> it would get the data stored at physical memory location <code class="docutils literal notranslate"><span class="pre">0x1234</span></code>.   For example, the original Microsoft DOS operating system, supported exactly this model.</p>
<p>As shown in <a class="reference internal" href="#mem-pys-mem-fig"><span class="std std-numref">Fig. 23.1</span></a>, the operating system needs to be loaded into one part of the memory, and each program that you would want to run needs to be loaded into different physical memory at different addresses.</p>
<figure class="align-default" id="mem-pys-mem-fig">
<a class="reference internal image-reference" href="../_images/physmem.drawio.png"><img alt="../_images/physmem.drawio.png" src="../_images/physmem.drawio.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.1 </span><span class="caption-text">Operating system is loaded at address 0, program 1 is loaded at address <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> and program 2 is loaded at address <code class="docutils literal notranslate"><span class="pre">0x8000</span></code></span><a class="headerlink" href="#mem-pys-mem-fig" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>There are two major problems with physical memory management.  First, there is no protection between the different programs.  A bug in program 1 may cause program 2 to be modified, or even modify the operating system.</p>
<p>Second, programs need to be re-located when they are loaded.  If we are going to run multiple programs, we can’t know a-priori the location where the program will be loaded.  However, when the program is compiled and linked into object code specific addresses, for example for branches needed to be specified in the program.</p>
<p>For this reason programs are usually linked as relocatable.  Relocatable programs have a table of all addresses within the program image that must be changed at load time before it can be run.   See <a class="reference internal" href="#prog-pys-mem-fig"><span class="std std-numref">Fig. 23.2</span></a>, where the jump instruction at address <code class="docutils literal notranslate"><span class="pre">0x0000</span></code> needs to be modified by adding the address of where the program is being loaded, i.e., <code class="docutils literal notranslate"><span class="pre">JMP</span> <span class="pre">0x1000</span></code> is modified to <code class="docutils literal notranslate"><span class="pre">JMP</span> <span class="pre">0x3000</span></code>.</p>
<figure class="align-default" id="prog-pys-mem-fig">
<a class="reference internal image-reference" href="../_images/prog_phys.drawio.png"><img alt="../_images/prog_phys.drawio.png" src="../_images/prog_phys.drawio.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.2 </span><span class="caption-text">Changes to program 1 to load it at address <code class="docutils literal notranslate"><span class="pre">0x2000</span></code></span><a class="headerlink" href="#prog-pys-mem-fig" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>While we don’t need relocation to solve this problem with paged virtual memory, as we will discuss layer, relocation is still used today for shared libraries and for address space randomization.</p>
</section>
<section id="segmentation-virtual-memory">
<span id="cont-mm-virt-seg"></span><h2><span class="section-number">23.2. </span>Segmentation - Virtual Memory<a class="headerlink" href="#segmentation-virtual-memory" title="Permalink to this headline">#</a></h2>
<p>Physical memory managment has the 2 problems; there is no isolation and you need to relocate programs to wherever they are loaded.  What we really want is <em>virtual memory</em> where every process has an address space that appears to start at address<code class="docutils literal notranslate"><span class="pre">0x0000</span></code> and ends at some large address based on underlying hardware design.  This way every process is isolated from every other process because it can only see its own virtual memory and every program can be loaded at wherever it was linked to run without relocation.</p>
<figure class="align-default" id="multiple-virtual-address-spaces">
<a class="reference internal image-reference" href="../_images/programs_seg.png"><img alt="../_images/programs_seg.png" src="../_images/programs_seg.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.3 </span><span class="caption-text">Multiple virtual address spaces using segmentation</span><a class="headerlink" href="#multiple-virtual-address-spaces" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="segmentation-base-and-bounds-translation">
<h3><span class="section-number">23.2.1. </span>Segmentation - Base and Bounds translation<a class="headerlink" href="#segmentation-base-and-bounds-translation" title="Permalink to this headline">#</a></h3>
<p>We first looked at direct physical addressing, where no matter which
process is executing, the same address (e.g. 0x1000) refers to the same
memory location. In addition we reviewed a very simple form of address
translation, shown here in <a class="reference internal" href="#mm-base-bound"><span class="std std-numref">Fig. 23.5</span></a></p>
<p>where base and bounds registers are used to
relocate a section of the <em>virtual address space</em>—the addresses seen
by the program, corresponding to values in the CPU registers—to
somewhere else in the physical address space. By changing these
translations the operating system can create multiple virtual address
spaces, one per process; however there is still only one physical
address space, uniquely identifying each byte in each memory chip. In
this chapter we introduce <em>paged address translation</em>, a more complex
address translation mechanism used by most modern CPUs, and present the
32-bit Intel implementation as an example.</p>
<figure class="align-default" id="b-l">
<a class="reference internal image-reference" href="../_images/B&amp;Lregs.png"><img alt="../_images/B&amp;Lregs.png" src="../_images/B&amp;Lregs.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.4 </span><span class="caption-text">Base and Limit registers</span><a class="headerlink" href="#b-l" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="segmentation-aka-base-and-bounds-translation">
<h2><span class="section-number">23.3. </span>Segmentation(AKA base and bounds translation).<a class="headerlink" href="#segmentation-aka-base-and-bounds-translation" title="Permalink to this headline">#</a></h2>
<p>In the simplest form of segmentation the hardware provides 2 registers that are loaded each time a process acquire the CPU, a base register and a limit register.  For a given process the base register contains the physical address that the program was loaded at and the limit register contains the size of the program that was loaded into memory.  Every process has a virtual address space starting at zero and a size determined by the actual program size that the process is running.  The process specific base and limit registers which are loaded every time a process acquires the CPU establishes the bounds of the virtual address space for every process.  For each and every memory reference the hardware adds the virtual address to the base register to determine a physical address and insures that the physical address is between the base register and base register plus the limit register.  If it is outside those bounds the program is terminated with an illegal virtual memory reference error.  Segmentation solves both the lack of protection and the mandatory relocation requirements of physical addressing.  Segmentation has little or no performance overhead because the hardware performs the virtual to physical translation or the addition of the virtual address and the base register to determine every physical address.</p>
<figure class="align-default" id="mm-base-bound">
<a class="reference internal image-reference" href="../_images/virt-mem-base-bounds.png"><img alt="../_images/virt-mem-base-bounds.png" src="../_images/virt-mem-base-bounds.png" style="width: 45%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.5 </span><span class="caption-text">Base-bound registers for translation</span><a class="headerlink" href="#mm-base-bound" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="single-segments-per-address-space">
<h3><span class="section-number">23.3.1. </span>Single segments per address space<a class="headerlink" href="#single-segments-per-address-space" title="Permalink to this headline">#</a></h3>
<p>So far we discussed a segmentation implementation that provides one base register and one limit register in hardware and one of each of those process specific values that gets loaded into those registers when context switching to a given process.  Since there is only one of each register, the entire process virtual address space must be physically contiguous and all text, data and stack must be within that single memory region.  While this is a huge improvement over a physical memory model it limits the size of the virtual address space to being static and not expandable.  There is no way to dynamically increase the size of the text, data or stack regions of a process at run-time, everything must be allocated in advance.  This requires allocating physical memory that might never be used.</p>
<figure class="align-default" id="segment-ex1">
<a class="reference internal image-reference" href="../_images/segment_ex1.png"><img alt="../_images/segment_ex1.png" src="../_images/segment_ex1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.6 </span><span class="caption-text">Single Segment per process</span><a class="headerlink" href="#segment-ex1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Since every process has different base and limit register values segmentation can easily support multiple processes.</p>
<figure class="align-default" id="segment-ex2">
<a class="reference internal image-reference" href="../_images/segment_ex2.png"><img alt="../_images/segment_ex2.png" src="../_images/segment_ex2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.7 </span><span class="caption-text">Multiple processes using Segmentation</span><a class="headerlink" href="#segment-ex2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="multiple-segments-per-address-space">
<h3><span class="section-number">23.3.2. </span>Multiple segments per address space.<a class="headerlink" href="#multiple-segments-per-address-space" title="Permalink to this headline">#</a></h3>
<p>As mentioned earlier a single base and limit segment register implies that an entire process virtual address space is a one physically contiguous region of physical memory mapped into one virtually contiguous virtual region of virtual memory.  This means that the text, data and stack regions must be packed tightly together in both physical and virtual memory unless we are willing to waste both physical and virtual memory.  Also, with only one segment register its not possible to offer different types of protections for the various regions of the virtual address space.  In other words all of virtual memory must be readable, writable and executable since data must be both readable and writable and text must be executable.  It would be nice to prevent data regions from being executable and text regions from being readable and writable for security and debug optimizations.</p>
<p>This can be achieved by the hardware implementing multiple segment and limit registers with only specified permissions for text, data and stack regions and having the operating system use those registers when context switching to a process.  When mapping the text into a virtual region the operating system can specify an execute only region that does not have to be adjacent to other non-executable regions.  When mapping data into virtual memory the operating system can specify read/write only thereby preventing execution of data regions.  Finally the stack can also be non-executable but also the operating system can move the virtual memory stack region away from any other region making it easier to debug common programming problems like stack overflows.  Finally multiple segment registers eliminates the necessity for the text, data and stack regions to be physically contiguous.  This allows a program to be split up into multiple smaller regions both physically and virtually making it much easier to hold more programs in physical memory at the same time.</p>
<figure class="align-default" id="segment-multi">
<a class="reference internal image-reference" href="../_images/segmentation-multi.png"><img alt="../_images/segmentation-multi.png" src="../_images/segmentation-multi.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.8 </span><span class="caption-text">Multiple Segments per address space</span><a class="headerlink" href="#segment-multi" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="private-versus-global-segments">
<h3><span class="section-number">23.3.3. </span>Private versus Global segments.<a class="headerlink" href="#private-versus-global-segments" title="Permalink to this headline">#</a></h3>
<p>Every process virtual address space consists of 2 types of regions, Private and Global.  The private regions for a process are the program specific text, data and stack regions that the process is running.  The global regions include the operating system that is and must be mapped into every process address space.  As we discussed earlier in this course the operating system consists of all the software that executes on behalf of the currently running program as well as basic system overhead that runs on behalf of the system.  This includes all the system calls the operating system supports.  Since every process must map the operating system kernel it is shared between every running process rather than each process containing a separate copy.  The global segment registers are used to map the shared kernel text, data and kernel stack area in every process and at the same virtual addresses.  When a context switch occurs only the private segments registers are changed for the newly running process, there is no need to change the global segment registers since they are identical for every process.</p>
<figure class="align-default" id="segment-global">
<a class="reference internal image-reference" href="../_images/segmentation-global.png"><img alt="../_images/segmentation-global.png" src="../_images/segmentation-global.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.9 </span><span class="caption-text">Global Segments</span><a class="headerlink" href="#segment-global" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="fragmentation-and-compaction">
<h4><span class="section-number">23.3.3.1. </span>Fragmentation and Compaction.<a class="headerlink" href="#fragmentation-and-compaction" title="Permalink to this headline">#</a></h4>
<p>When a new process is created and a program runs the kernel reads the program text, data and stack memory into the available or free physical memory locations.  From there the private segment registers are use to map that physical memory into the private virtual address space of the process, allowing the process to run the program.  When a process exits, the physical memory regions that the process consumed is made available or freed onto a physical memory free list.  Over time as processes are created, run and exit the physical memory becomes more and more fragmented.  After a while as processes come and go its likely that the sum of available physical memory is large enough to satisfy a request but there is no physically contiguous free memory region large enough to hold the request.</p>
<p>For example if memory is allocated and de-allocated in chunks of different sizes and at different times, then it can  become <em>fragmented</em> so that even if large amounts of memory are free, it will be divided into smaller fragments, separated by longer-lived small allocations, as seen in (#fig:vm:fig2).</p>
<p>Start: 32 locations, all free</p>
<figure class="align-default" id="mm-virt-mem-frag-1">
<a class="reference internal image-reference" href="../_images/virt-mem-frag-1.png"><img alt="../_images/virt-mem-frag-1.png" src="../_images/virt-mem-frag-1.png" style="width: 45%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.10 </span><span class="caption-text">Everything is free</span><a class="headerlink" href="#mm-virt-mem-frag-1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Step 1, 2: Load and run processes A and B</p>
<figure class="align-default" id="mm-virt-mem-frag-2">
<a class="reference internal image-reference" href="../_images/virt-mem-frag-2.png"><img alt="../_images/virt-mem-frag-2.png" src="../_images/virt-mem-frag-2.png" style="width: 45%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.11 </span><span class="caption-text">Process A allocates 10 and process B allocates 1</span><a class="headerlink" href="#mm-virt-mem-frag-2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Step 3, 4, 5: Run and load processes C, D and E.</p>
<figure class="align-default" id="mm-virt-mem-frag-3">
<a class="reference internal image-reference" href="../_images/virt-mem-frag-3.png"><img alt="../_images/virt-mem-frag-3.png" src="../_images/virt-mem-frag-3.png" style="width: 45%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.12 </span><span class="caption-text">Process C allocates 10, process D allocates 1 and process E allocates 10</span><a class="headerlink" href="#mm-virt-mem-frag-3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Steps 6, 7, 8: processes A, C and D terminate</p>
<figure class="align-default" id="mm-virt-mem-frag-4">
<a class="reference internal image-reference" href="../_images/virt-mem-frag-4.png"><img alt="../_images/virt-mem-frag-4.png" src="../_images/virt-mem-frag-4.png" style="width: 45%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.13 </span><span class="caption-text">process A frees 10, process C frees 1 and process E frees 10</span><a class="headerlink" href="#mm-virt-mem-frag-4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In the last line, you can see that only 2 units of memory (out of 32)
remain allocated, but the largest amount that can be allocated at one
time is 10 units. If all allocation requests are small, this might not
be a problem; however, in an operating system it is common to have one
or two very large processes (e.g., a web browser and word processing
software), and many small, long-running processes (e.g., the on-screen
battery display or wifi signal strength indicator). In this case, large
memory allocations may fail, even when there is enough total memory
free, because long-lived small allocations fragment the available
contiguous memory into smaller pieces.</p>
<p>When this happens the operating system must move or coalesce the used memory regions together thereby creating a large contiguous available or free region.  Even though this is very time consuming and not desirable at least now one or more requests can be satisfied.  This is all made possible because the base registers of the processes that map these moved regions can be updated to the new locations of the physical memory and because the operating system has the ability to relocate programs in physical memory as we discussed in the physical memory management model.  Again, this is time consuming and undesirable.</p>
</section>
<section id="swapping">
<h4><span class="section-number">23.3.3.2. </span>Swapping.<a class="headerlink" href="#swapping" title="Permalink to this headline">#</a></h4>
<p>Since the entire process must be resident in physical memory to run with segmentation, its unlikely that all processes will be able to run at the same time. In order to support more processes than can fit into memory the memory management system must swap entire processes out to disk when memory is needed and into memory from disk when they need to run again.</p>
<p>The memory management system has determined that process 1 had run long enough so it swaps it out and frees up memory it occupies.</p>
<figure class="align-default" id="swapout">
<a class="reference internal image-reference" href="../_images/swapout.png"><img alt="../_images/swapout.png" src="../_images/swapout.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.14 </span><span class="caption-text">Swapping out an entire process</span><a class="headerlink" href="#swapout" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The memory management system has determined that its time for process N to run again so it swaps it into the memory freed by the swapout.</p>
<figure class="align-default" id="swapin">
<a class="reference internal image-reference" href="../_images/swapin.png"><img alt="../_images/swapin.png" src="../_images/swapin.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.15 </span><span class="caption-text">Swapping in an entire process</span><a class="headerlink" href="#swapin" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="limitations-of-segmentation">
<h4><span class="section-number">23.3.3.3. </span>Limitations of segmentation.<a class="headerlink" href="#limitations-of-segmentation" title="Permalink to this headline">#</a></h4>
<p>Segmentation, especially with multiple segment registers along with private and global segment registers provides a huge benefit over a physical memory management model.  We can now support many processes running at the same time with protection between processes and even protection within a process.  However Segmentation still has major weaknesses, 1.) the memory for a segment must be physically contiguous, 2.) the virtual address size can never exceed the physical address size with segmentation.  Needing physically contiguous memory is a huge problem, it requires compaction and swapping in order to run a significant number of processes simultaneously.  Limiting programs to less that the amount of physical memory on a given system is also very limiting.  It would be very convenient to be able to allocate a very large sparse region of virtual memory and only actually use a small subset of it.  Imagine allocating an array of fixed size records for every possible student at Boston University and indexing that array by the student’s social security number.  There are 10^9 or 1 Billion social security numbers but only a few thousand students at BU.  Such a large sparse array could not be implemented with segmentation unless the system actually had all the necessary physical memory for every possible social security number.  Imagine being able to map millions of files in a virtual address space on a system that didn’t have all that much physical memory.</p>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./mm"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">22. </span>Introduction</p>
      </div>
    </a>
    <a class="right-next"
       href="virt-paging.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">24. </span>Paging</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#simple-physical-memory-management">23.1. Simple physical memory management.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-virtual-memory">23.2. Segmentation - Virtual Memory</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-base-and-bounds-translation">23.2.1. Segmentation - Base and Bounds translation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-aka-base-and-bounds-translation">23.3. Segmentation(AKA base and bounds translation).</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#single-segments-per-address-space">23.3.1. Single segments per address space</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-segments-per-address-space">23.3.2. Multiple segments per address space.</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#private-versus-global-segments">23.3.3. Private versus Global segments.</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fragmentation-and-compaction">23.3.3.1. Fragmentation and Compaction.</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#swapping">23.3.3.2. Swapping.</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#limitations-of-segmentation">23.3.3.3. Limitations of segmentation.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By (see contributing chapter book)
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>